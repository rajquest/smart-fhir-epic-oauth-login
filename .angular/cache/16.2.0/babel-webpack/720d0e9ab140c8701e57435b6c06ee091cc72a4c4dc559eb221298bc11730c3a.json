{"ast":null,"code":"(function () {\n  var merge = require('merge');\n  var RTRIM = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n  var trim = function (text) {\n    return text ? text.toString().replace(RTRIM, \"\") : \"\";\n  };\n  exports.trim = trim;\n  var addKey = function (acc, str) {\n    var pair, val;\n    if (!str) {\n      return null;\n    }\n    pair = str.split(\"=\").map(trim);\n    val = pair[1].replace(/(^\"|\"$)/g, '');\n    if (val) {\n      acc[pair[0]] = val;\n    }\n    return acc;\n  };\n  var type = function (obj) {\n    var classToType;\n    if (obj == null && obj === undefined) {\n      return String(obj);\n    }\n    classToType = {\n      '[object Boolean]': 'boolean',\n      '[object Number]': 'number',\n      '[object String]': 'string',\n      '[object Function]': 'function',\n      '[object Array]': 'array',\n      '[object Date]': 'date',\n      '[object RegExp]': 'regexp',\n      '[object Object]': 'object'\n    };\n    return classToType[Object.prototype.toString.call(obj)];\n  };\n  exports.type = type;\n  var assertArray = function (a) {\n    if (type(a) !== 'array') {\n      throw 'not array';\n    }\n    return a;\n  };\n  exports.assertArray = assertArray;\n  var assertObject = function (a) {\n    if (type(a) !== 'object') {\n      throw 'not object';\n    }\n    return a;\n  };\n  exports.assertObject = assertObject;\n  var reduceMap = function (m, fn, acc) {\n    var k, v;\n    acc || (acc = []);\n    assertObject(m);\n    return function () {\n      var results;\n      results = [];\n      for (k in m) {\n        v = m[k];\n        results.push([k, v]);\n      }\n      return results;\n    }().reduce(fn, acc);\n  };\n  exports.reduceMap = reduceMap;\n  var identity = function (x) {\n    return x;\n  };\n  exports.identity = identity;\n  var argsArray = function () {\n    return Array.prototype.slice.call(arguments);\n  };\n  exports.argsArray = argsArray;\n  var mergeLists = function () {\n    var reduce;\n    reduce = function (merged, nextMap) {\n      var k, ret, v;\n      ret = merge(true, merged);\n      for (k in nextMap) {\n        v = nextMap[k];\n        ret[k] = (ret[k] || []).concat(v);\n      }\n      return ret;\n    };\n    return argsArray.apply(null, arguments).reduce(reduce, {});\n  };\n  exports.mergeLists = mergeLists;\n  var absoluteUrl = function (baseUrl, ref) {\n    if (!ref.match(/https?:\\/\\/./)) {\n      return baseUrl + \"/\" + ref;\n    } else {\n      return ref;\n    }\n  };\n  exports.absoluteUrl = absoluteUrl;\n  var relativeUrl = function (baseUrl, ref) {\n    if (ref.slice(ref, baseUrl.length + 1) === baseUrl + \"/\") {\n      return ref.slice(baseUrl.length + 1);\n    } else {\n      return ref;\n    }\n  };\n  exports.relativeUrl = relativeUrl;\n  exports.resourceIdToUrl = function (id, baseUrl, type) {\n    baseUrl = baseUrl.replace(/\\/$/, '');\n    id = id.replace(/^\\//, '');\n    if (id.indexOf('/') < 0) {\n      return baseUrl + \"/\" + type + \"/\" + id;\n    } else if (id.indexOf(baseUrl) !== 0) {\n      return baseUrl + \"/\" + id;\n    } else {\n      return id;\n    }\n  };\n  var walk = function (inner, outer, data, context) {\n    var keysToMap, remapped;\n    switch (type(data)) {\n      case 'array':\n        return outer(data.map(function (item) {\n          return inner(item, [data, context]);\n        }), context);\n      case 'object':\n        keysToMap = function (acc, arg) {\n          var k, v;\n          k = arg[0], v = arg[1];\n          acc[k] = inner(v, [data].concat(context));\n          return acc;\n        };\n        remapped = reduceMap(data, keysToMap, {});\n        return outer(remapped, context);\n      default:\n        return outer(data, context);\n    }\n  };\n  exports.walk = walk;\n  var postwalk = function (f, data, context) {\n    if (!data) {\n      return function (data, context) {\n        return postwalk(f, data, context);\n      };\n    } else {\n      return walk(postwalk(f), f, data, context);\n    }\n  };\n  exports.postwalk = postwalk;\n}).call(this);","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}